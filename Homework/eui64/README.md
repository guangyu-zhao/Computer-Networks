# eui64

## 题目描述

在 IPv6 中，Link Local 地址变得比较重要，为了生成一个不会冲突的 Link Local 地址，有一种简单的办法（EUI-64），即利用 MAC 地址的唯一性，通过下面的方法，转换为 Link Local 的 IPv6 地址：

1. 输入一个 48 位的 MAC 地址，输出一个 128 位的 IPv6 地址
2. 设置 IPv6 地址的第 1 个字节为 0xFE，第 2 个字节为 0x80，第 3 到第 8 个字节设为 0。这一步设置了 IPv6 地址属于 Link Local 地址。
3. 把 MAC 地址分为两半写入 IPv6 地址：将 MAC 地址第 1 到第 3 个字节复制到 IPv6 地址的第 9 到第 11 个字节；再将第 4 到第 6 个字节复制到 IPv6 地址的第 14 到第 16 个字节。
4. 设置 IPv6 地址的第 12 个字节为 0xFF，第 13 个字节为 0xFE，填充了中间空出来的两个字节数据。
5. 把 IPv6 地址第 9 个字节按网络位序从左到右第 7 位（见 RFC 4291 中的图示）取反。

这个过程在 [RFC 4291](https://datatracker.ietf.org/doc/html/rfc4291) 中定义。

你需要在 `eui64.cpp` 文件中实现将这个转换过程实现中在下列的函数中。

```cpp
// 函数注释见代码
in6_addr eui64(const ether_addr mac) {
  in6_addr res = {0};
  // TODO
  return res;
}
```

`in6_addr` 类型保存了 IPv6 的 128 位地址信息，你可以通过 `uint8_t s6_addr[16]` 成员来读写，例如 `res.s6_addr[0] = 0xfe;`。类似地，`ether_addr` 类型通过 `uint8_t ether_addr_octet[6]` 成员来读写。

你不需要处理输入输出，你只需要在本地执行 `make grade` 就可以进行本地评测。

## 输入输出文件格式

输入文件有若干行，每一行一个 MAC 地址。

输出文件有若干行，每行一个 IPv6 地址，为输入文件中每一行 MAC 地址采用 EUI-64 算法生成的 IPv6 地址。

IPv6 地址采用 `inet_ntop` 函数将 IPv6 地址转换为字符串。简单来说，将 IPv6 地址的 16 个字节分别转换为十六进制，两个为一组，组之间由 `:` 分隔；如果有连续的 0000，那么可以省略。完整的规则见 [Wikipedia](https://en.wikipedia.org/wiki/IPv6_address#Representation)。

## 样例 1

见 data 目录下的 *eui64_input1.txt* 与 *eui64_answer1.txt*。

## 样例 1 解释

样例 1 的输入仅有一个 MAC 地址：11:22:33:44:55:66，按照要求的算法进行处理：

1. 设置 IPv6 地址的前 8 个字节，得到 fe80:0000:0000:0000:0000:0000:0000:0000。
2. 把 MAC 地址分为两部分填入，得到 fe80:0000:0000:0000:1122:3300:0044:5566。
3. 填入中间的空位，得到 fe80:0000:0000:0000:1122:33ff:fe44:5566。
4. 将 11 的从低到高 2 位取反，即 13，得到 fe80:0000:0000:000:1322:33ff:fe44:5566。
5. main 函数采用 inet_ntop 函数输出 IPv6 地址，连续的零省略为 ::，得到最终结果 fe80::1322:33ff:fe44:5566。
